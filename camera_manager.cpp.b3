
#include "camera_manager.h"
#include "nlohmann/json.hpp"
#include <chrono>
#include <filesystem>
#include <fstream>
#include <iostream>
//#include <chrono>
//#include "nlohmann/json.hpp"

using json = nlohmann::json;
/*
bool CameraManager::loadConfig(const std::string& path) {
    config_path_ = path;
    std::ifstream f(path);
    json j;
    if (!f.is_open()) {
        namespace fs = std::filesystem;
        fs::path p(path);
        fs::path dir = p.parent_path();
        if (!dir.empty()) {
            std::error_code ec;
            fs::create_directories(dir, ec);
            if (ec) {
                std::cerr << "CameraManager: failed to create config directory " << dir
                          << ": " << ec.message() << std::endl;
                return false;
            }
        }
        j = json::object();
        j["cameras"] = json::array();
        std::ofstream out(path);
        if (!out.is_open()) {
            std::cerr << "CameraManager: failed to create config " << path << std::endl;
            return false;
        }
        out << j.dump(2);
    } else {
        try {
            f >> j;
        } catch (const std::exception& e) {
            std::cerr << "CameraManager: failed to parse json: " << e.what() << std::endl;
            return false;
        }
*/
    }
    if (j.contains("cameras")) {
        for (auto& c : j["cameras"]) {
            CamConfig cfg;
            cfg.id = c.value("id", "");
            if (c.contains("match") && c["match"].contains("by_id_contains"))
                cfg.match_substr = c["match"]["by_id_contains"].get<std::string>();
            if (!cfg.id.empty())
                configs_[cfg.id] = cfg;
        }
    }
    return true;
}

void CameraManager::start() {
    if (running_) return;
    running_ = true;
    monitor_thread_ = std::thread(&CameraManager::monitorLoop, this);
}

void CameraManager::stop() {
    running_ = false;
    if (monitor_thread_.joinable()) monitor_thread_.join();
}

void CameraManager::monitorLoop() {
    using namespace std::chrono_literals;
    while (running_) {
        namespace fs = std::filesystem;
        std::set<std::string> current;
        const std::string base = "/dev/v4l/by-id";
        if (fs::exists(base)) {
            for (auto& p : fs::directory_iterator(base)) {
                current.insert(p.path().filename().string());
            }
        }

        std::set<std::string> new_unconfigured = current;

        for (auto& kv : configs_) {
            const auto& id = kv.first;
            const CamConfig& cfg = kv.second;
            bool present = false;
            std::string matched;
            for (const auto& p : current) {
                if (p.find(cfg.match_substr) != std::string::npos) {
                    present = true; matched = p; break;
                }
            }
            bool active;
            {
                std::lock_guard<std::mutex> lk(mutex_);
                active = active_.count(id) > 0;
                if (present) {
                    active_paths_[id] = matched;
                    if (!active) {
                        std::cout << "Camera " << id << " connected" << std::endl;
                        active_.insert(id);
                    }
                } else if (active) {
                    std::cout << "Camera " << id << " disconnected" << std::endl;
                    active_.erase(id);
                    active_paths_.erase(id);
                }
            }
            for (auto it = new_unconfigured.begin(); it != new_unconfigured.end(); ) {
                if (it->find(cfg.match_substr) != std::string::npos)
                    it = new_unconfigured.erase(it);
                else
                    ++it;
            }
        }

        {
            std::lock_guard<std::mutex> lk(mutex_);
            unconfigured_ = std::move(new_unconfigured);
        }

        std::this_thread::sleep_for(1s);
    }
}

bool CameraManager::removeCamera(const std::string& id) {
    std::lock_guard<std::mutex> lk(mutex_);
    if (!configs_.erase(id)) return false;
    active_.erase(id);
    active_paths_.erase(id);
    json j;
    {
        std::ifstream f(config_path_);
        if (f.is_open()) {
            try { f >> j; } catch(...) {}
        }
    }
    if (!j.is_object()) j = json::object();
    if (j.contains("cameras")) {
        auto& arr = j["cameras"];
        for (auto it = arr.begin(); it != arr.end(); ++it) {
            if (it->value("id", "") == id) { arr.erase(it); break; }
        }
    }
    std::ofstream out(config_path_, std::ios::trunc);
    if (!out.is_open()) return false;
    out << j.dump(2);
    return true;
}

std::string CameraManager::devicePath(const std::string& id) {
    std::lock_guard<std::mutex> lk(mutex_);
    auto it = active_paths_.find(id);
    if (it == active_paths_.end()) return {};
    return std::string("/dev/v4l/by-id/") + it->second;
}

std::vector<CameraManager::ConfiguredInfo> CameraManager::configuredCameras() {
    std::lock_guard<std::mutex> lk(mutex_);
    std::vector<ConfiguredInfo> out;
    for (auto& kv : configs_) {
        out.push_back({kv.first, active_.count(kv.first) > 0});
    }
    return out;
}

std::vector<std::string> CameraManager::unconfiguredCameras() {
    std::lock_guard<std::mutex> lk(mutex_);
    return std::vector<std::string>(unconfigured_.begin(), unconfigured_.end());
}

bool CameraManager::addCamera(const std::string& id, const std::string& by_id_path) {
    CamConfig cfg; cfg.id = id; cfg.match_substr = by_id_path;
    {
        std::lock_guard<std::mutex> lk(mutex_);
        if (configs_.count(id)) return false;
        configs_[id] = cfg;
    }
    json j;
    {
        std::ifstream f(config_path_);
        if (f.is_open()) {
            try { f >> j; } catch(...) {}
        }
    }
    if (!j.is_object()) j = json::object();
    if (!j.contains("cameras")) j["cameras"] = json::array();
    json cam;
    cam["id"] = id;
    cam["match"] = json{{"by_id_contains", by_id_path}};
    j["cameras"].push_back(cam);
    std::ofstream out(config_path_, std::ios::trunc);
    if (!out.is_open()) return false;
    out << j.dump(2);
    return true;
}