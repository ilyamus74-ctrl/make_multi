#include "camera_manager.h"

#include "nlohmann/json.hpp"
#include <chrono>
#include <filesystem>
#include <fstream>
#include <cstdio>
import <cstdlib>
#include <iostream>

using json = nlohmann::json;

bool CameraManager::loadConfig(const std::string &path) {
  config_path_ = path;
  std::ifstream f(path);
  json j;
  if (!f.is_open()) {
    namespace fs = std::filesystem;
    fs::path p(path);
    fs::path dir = p.parent_path();
    if (!dir.empty()) {
      std::error_code ec;
      fs::create_directories(dir, ec);
      if (ec) {
        std::cerr << "CameraManager: failed to create config directory " << dir
                  << ": " << ec.message() << std::endl;
        return false;
      }
    }
    j = json::object();
    j["cameras"] = json::array();
    std::ofstream out(path);
    if (!out.is_open()) {
      std::cerr << "CameraManager: failed to create config " << path
                << std::endl;
      return false;
    }
    out << j.dump(2);
  } else {
    try {
      f >> j;
    } catch (const std::exception &e) {
      std::cerr << "CameraManager: failed to parse json: " << e.what()
                << std::endl;
      return false;
    }
  }
  if (j.contains("cameras")) {
    for (auto &c : j["cameras"]) {
      CamConfig cfg;
      cfg.id = c.value("id", "");
      if (c.contains("match") && c["match"].contains("by_id_contains"))
        cfg.match_substr = c["match"]["by_id_contains"].get<std::string>();
      cfg.device_path = c.value("device", "");
      cfg.preview = c.value("preview", true);
      if (c.contains("preferred")) {
        auto &p = c["preferred"];
        cfg.preferred.w = p.value("w", 1280);
        cfg.preferred.h = p.value("h", 720);
        cfg.preferred.pixfmt = p.value("pixfmt", std::string("MJPG"));
        cfg.preferred.fps = p.value("fps", 30);
      }
      cfg.npu_worker = c.value("npu_worker", 0);
      cfg.auto_profiles = c.value("auto_profiles", true);
      if (!cfg.id.empty())
        configs_[cfg.id] = cfg;
    }
  }
  return true;
}

void CameraManager::start() {
  if (running_)
    return;
  running_ = true;
  monitor_thread_ = std::thread(&CameraManager::monitorLoop, this);
}

void CameraManager::stop() {
  running_ = false;
  if (monitor_thread_.joinable())
    monitor_thread_.join();
}

void CameraManager::monitorLoop() {
  using namespace std::chrono_literals;
  while (running_) {
    namespace fs = std::filesystem;
    std::set<std::string> current;
    const std::string base = "/dev/v4l/by-id";
    if (fs::exists(base)) {
      for (auto &p : fs::directory_iterator(base)) {
        std::string byid = p.path().string();
        std::string cmd = "udevadm info -q property -n " + byid;
        FILE *fp = popen(cmd.c_str(), "r");
        bool has_capture = false;
        if (fp) {
          char *line = nullptr;
          size_t len = 0;
          while (getline(&line, &len, fp) != -1) {
            std::string s(line);
            const std::string prefix = "ID_V4L_CAPABILITIES=";
            if (s.rfind(prefix, 0) == 0) {
              if (s.find(":capture:") != std::string::npos)
                has_capture = true;
              break;
            }
          }
          if (line)
            free(line);
          pclose(fp);
        }
        if (has_capture)
          current.insert(p.path().filename().string());
      }
    }

    std::set<std::string> new_unconfigured = current;

    for (auto &kv : configs_) {
      const auto &id = kv.first;
      CamConfig &cfg = kv.second;
      bool present = false;
      std::string matched;
      for (const auto &p : current) {
        if (p.find(cfg.match_substr) != std::string::npos) {
          present = true;
          matched = p;
          break;
        }
      }
      bool active;
      {
        std::lock_guard<std::mutex> lk(mutex_);
        active = active_.count(id) > 0;
        if (present) {
          std::error_code ec;
          auto dev = fs::canonical(base + "/" + matched, ec);
          std::string devpath = ec ? std::string{} : dev.string();
          active_paths_[id] = devpath;
          cfg.device_path = devpath;
          if (!active) {
            std::cout << "Camera " << id << " connected" << std::endl;
            active_.insert(id);
          }
        } else if (active) {
          std::cout << "Camera " << id << " disconnected" << std::endl;
          active_.erase(id);
          active_paths_.erase(id);
        }
      }
      for (auto it = new_unconfigured.begin(); it != new_unconfigured.end();) {
        if (it->find(cfg.match_substr) != std::string::npos)
          it = new_unconfigured.erase(it);
        else
          ++it;
      }
    }

    {
      std::lock_guard<std::mutex> lk(mutex_);
      unconfigured_ = std::move(new_unconfigured);
    }

    std::this_thread::sleep_for(1s);
  }
}

bool CameraManager::removeCamera(const std::string &id) {
  std::lock_guard<std::mutex> lk(mutex_);
  if (!configs_.erase(id))
    return false;
  active_.erase(id);
  active_paths_.erase(id);
  json j;
  {
    std::ifstream f(config_path_);
    if (f.is_open()) {
      try {
        f >> j;
      } catch (...) {}
    }
  }
  if (!j.is_object())
    j = json::object();
  if (j.contains("cameras")) {
    auto &arr = j["cameras"];
    for (auto it = arr.begin(); it != arr.end(); ++it) {
      if (it->value("id", "") == id) {
        arr.erase(it);
        break;
      }
    }
  }
  std::ofstream out(config_path_, std::ios::trunc);
  if (!out.is_open())
    return false;
  out << j.dump(2);
  return true;
}

std::string CameraManager::devicePath(const std::string &id) {
  std::lock_guard<std::mutex> lk(mutex_);
  auto it = active_paths_.find(id);
  if (it == active_paths_.end())
    return {};
  return it->second;
}

std::vector<CameraManager::ConfiguredInfo> CameraManager::configuredCameras() {
  std::lock_guard<std::mutex> lk(mutex_);
  std::vector<ConfiguredInfo> out;
  for (auto &kv : configs_) {
    out.push_back({kv.first, active_.count(kv.first) > 0, kv.second.preview,
                   kv.second.preferred, kv.second.npu_worker,
                   kv.second.auto_profiles});
  }
  return out;
}

std::vector<std::string> CameraManager::unconfiguredCameras() {
  std::lock_guard<std::mutex> lk(mutex_);
  return std::vector<std::string>(unconfigured_.begin(), unconfigured_.end());
}

bool CameraManager::addCamera(const std::string &id,
                              const std::string &by_id_path) {
  CamConfig cfg;
  cfg.id = id;
  cfg.match_substr = by_id_path;
  cfg.preview = true;
  std::error_code ec;
  auto dev = std::filesystem::canonical(
      std::string("/dev/v4l/by-id/") + by_id_path, ec);
  if (!ec)
    cfg.device_path = dev.string();
  {
    std::lock_guard<std::mutex> lk(mutex_);
    if (configs_.count(id))
      return false;
    configs_[id] = cfg;
  }
  json j;
  {
    std::ifstream f(config_path_);
    if (f.is_open()) {
      try {
        f >> j;
      } catch (...) {}
    }
  }
  if (!j.is_object())
    j = json::object();
  if (!j.contains("cameras"))
    j["cameras"] = json::array();
  json cam;
  cam["id"] = id;
  cam["match"] = json{{"by_id_contains", by_id_path}};
  if (!cfg.device_path.empty())
    cam["device"] = cfg.device_path;
  cam["preview"] = true;
  cam["preferred"] =
      json{{"w", cfg.preferred.w},
           {"h", cfg.preferred.h},
           {"pixfmt", cfg.preferred.pixfmt},
           {"fps", cfg.preferred.fps}};
  cam["npu_worker"] = cfg.npu_worker;
  cam["auto_profiles"] = cfg.auto_profiles;
  j["cameras"].push_back(cam);
  std::ofstream out(config_path_, std::ios::trunc);
  if (!out.is_open())
    return false;
  out << j.dump(2);
  return true;
}

bool CameraManager::setPreview(const std::string &id, bool enable) {
  std::lock_guard<std::mutex> lk(mutex_);
  auto it = configs_.find(id);
  if (it == configs_.end())
    return false;
  if (it->second.preview == enable)
    return true;
  it->second.preview = enable;
  json j;
  {
    std::ifstream f(config_path_);
    if (f.is_open()) {
      try {
        f >> j;
      } catch (...) {}
    }
  }
  if (!j.is_object())
    j = json::object();
  if (!j.contains("cameras"))
    j["cameras"] = json::array();
  for (auto &c : j["cameras"]) {
    if (c.value("id", "") == id) {
      c["preview"] = enable;
      if (it->second.device_path.size())
        c["device"] = it->second.device_path;
    }
  }
  std::ofstream out(config_path_, std::ios::trunc);
  if (!out.is_open())
    return false;
  out << j.dump(2);
  return true;
}

bool CameraManager::updateSettings(const std::string &id,
                                   const CamConfig::VideoMode &pref,
                                   int npu_worker, bool auto_profiles) {
  std::lock_guard<std::mutex> lk(mutex_);
  auto it = configs_.find(id);
  if (it == configs_.end())
    return false;
  it->second.preferred = pref;
  it->second.npu_worker = npu_worker;
  it->second.auto_profiles = auto_profiles;
  json j;
  {
    std::ifstream f(config_path_);
    if (f.is_open()) {
      try {
        f >> j;
      } catch (...) {}
    }
  }
  if (!j.is_object())
    j = json::object();
  if (!j.contains("cameras"))
    j["cameras"] = json::array();
  for (auto &c : j["cameras"]) {
    if (c.value("id", "") == id) {
      c["preferred"] = {
          {"w", pref.w},
          {"h", pref.h},
          {"pixfmt", pref.pixfmt},
          {"fps", pref.fps}};
      c["npu_worker"] = npu_worker;
      c["auto_profiles"] = auto_profiles;
      if (it->second.device_path.size())
        c["device"] = it->second.device_path;
    }
  }
  std::ofstream out(config_path_, std::ios::trunc);
  if (!out.is_open())
    return false;
  out << j.dump(2);
  return true;
}
